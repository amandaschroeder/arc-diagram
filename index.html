<!doctype html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.8/d3.min.js" type="text/JavaScript"></script>
    <style>
      body {
        font-family: Lucide Sans Unicode, Tahoma, Verdana, sans-serif;
        fill: #CF7D1C;
        font-size: 11px;
      }
      .arc {
        stroke: #9A8B7A;
        fill: none;
      }
      .node {
        fill: #EBD8C1;
        stroke-width: 1px;
      }
      circle.active {
        fill: #FE9922;
      }
      path.active {
        stroke: #FE9922;
      }
      circle.source {
        fill: #FE9922;
      }
      circle.target {
        fill: #FE9922;
      }
      h4 {
        color: #CF7D1C;
      }
    </style>
  </head>
  <body>
    <h3>Basic Arc Diagram</h3>
    <p>An arc diagram arranges nodes along a line and draws the links as arcs above (forward progression) and/or below (backwards movement) that line in order to provide a sense of directionality of connections.

    <ul><li>nodes: things being connected</li>
    <li>edges or links: connections between them</li></ul>

    Goal: to show progression through steps, which can be applied to a variety of use cases (not just ecommerce checkout steps, for example). We also want to account for skips over steps and exits from specific steps.

    </p>
    <div id="viz">
      <p>Hover over the nodes to highlight them in orange. The width of the edges correslate to the weight of the connection.
      </p>
      <h4>Forward progression above -></h4>
      <svg style="width:800px;height:400px;" ></svg>
    </div>
    <script>
        /*
        *  Tips:
        *    - remove the .arc styles above for an entirely different look
        *
        * @TODO: 
        *   - add additional data to nodeslist.csv to determine whether link goes forward or backward, 
        *   use that as an attribute and color the links differently
        */


      var PromiseWrapper = d => new Promise(resolve => d3.csv(d, p => resolve(p)));

      Promise
        .all([
          PromiseWrapper("nodelist2.csv"),
          PromiseWrapper("edgelist2.csv")
        ])
        .then(resolve => {
          createArcDiagram(resolve[0], resolve[1])
        });

      function createArcDiagram(nodes,edges) {
        var nodeHash = {};
        // x is just an index
        nodes.forEach((node, x) => {
          nodeHash[node.id] = node;
          // node at index x, turn x into an int and multiply it by 30
          // this will become our x-axis
          node.x = parseInt(x) * 60;
          // not in use, but will be used as y axis when we convert this into a vertical diagram
          node.y = parseInt(x) * 60;
        });

        edges.forEach(edge => {
          // width of arc based on weight of the connection
          edge.weight = parseInt(edge.weight);
          edge.source = nodeHash[edge.source];
          edge.target = nodeHash[edge.target];
        });

        var arcG = d3.select("svg").append("g").attr("id", "arcG")
            .attr("transform", "translate(50,150)");

        arcG.selectAll("path")
          .data(edges)
          .enter()
          .append("path")
            .attr("class", "arc")
            .style("stroke-width", d => d.weight * 2)
            .style("opacity", .25)
            .attr("d", arc);

/* temp remove circles - maybe replace with rects?
        arcG.selectAll("circle")
          .data(nodes)
          .enter()
          .append("circle")
            .attr("class", "node")
            .attr("node", d => d.id)
            .attr("r", 10)
            .attr("cx", d => d.x);
*/

        arcG.selectAll("text")
            .data(nodes)
            .enter()
         .append("text")
            .attr("class", "label");

        arcG.selectAll("text.label")
            //.attr("x", function(d) { return d.x; })
            //.attr("y", function(d) { return 40; })
            .attr("transform",function(d,i){
                return "translate(" + d.x + ",10) rotate(50)"
            })
            .text(d => d.id)
            .attr("font-family", "sans-serif")
            .style("text-anchor", "middle")
            .attr("color", "#FE9922")
            .attr("font-size", "20px");
            //.attr("transform", "translate(0,25) rotate(50)");

/* the rotate is about the origin of the current user coordinate system

accepted
Rotation is relative to an element's parent origin:

the rotate is about the origin of the current user coordinate system.(source)

unless specifying a rotational point. Since all your text shares the same coordinate system (that of the parent g),
they all get rotated together, as a block as you note. And they are rotated around [0,0] of the parent g,
not around their anchor or any point related to where the text lies.

Instead of appending text directly to the chart's g, you could append each label to its own g.
If each of these g elements are transformed so that their origins correspond to text locations, rotation becomes easy.

*/
        /** On mouseover, nodes highlighted in orange
         *  On click of an edge, source and target nodes turn green and dark green
         *
        */

        d3.selectAll("circle").on("mouseover", nodeOver);
        d3.selectAll("path").on("mouseover", edgeOver);
        function nodeOver(d) {
          d3.selectAll("circle").classed("active", p => p === d);
          d3.selectAll("path").classed("active", p => p.source === d
            || p.target === d);
        }
        function edgeOver(d) {
          d3.selectAll("path").classed("active", p => p === d);
          d3.selectAll("circle")
            .classed("source", p => p === d.source)
            .classed("target", p => p === d.target);
        }

        function arc(d,i) {
          var draw = d3.line().curve(d3.curveBasis);
          var midX = (d.source.x + d.target.x) / 2;
          var midY = (d.source.x - d.target.x);
          return draw([[d.source.x,0],[midX,midY],[d.target.x,0]]);
        }
      }
    </script>
    <h4><- Reverse below</h4>
    <div id="footer">
      <p>In nodelist2.csv, you could append additional data about each step if useful (id,something,something)</p>
    </div>
  </body>
</html>
